<link rel="stylesheet" href="/styles/chat.css">
<link rel="stylesheet" href="/styles/global/chat-common.css">

<div class="container py-3">
  <div class="card">
    <div class="card-header text-center">
      <span class="marca-texto-verde"><%= locals.title %></span>
    </div>

    <div id="chat-container" class="card-body position-relative" style="height:500px; overflow-y:auto; display:flex; flex-direction:column;">
      <div id="loader" class="text-center my-2" style="display:none;">
        <span class="spinner-border spinner-border-sm"></span> Carregando...
      </div>
    </div>

    <div class="card-footer">
      <div class="input-group">
        <textarea id="input-msg" class="form-control" placeholder="Digite sua mensagem..." rows="1" style="resize: none; overflow-y: auto; max-height: 120px;"></textarea>
        <button id="send-btn" class="btn btn-primary">Enviar</button>
      </div>
    </div>
  </div>
</div>

<!-- Módulos globais -->
<script src="/js/global/ui-utils.js"></script>
<script src="/js/global/chat-utils.js"></script>

<!-- Reutiliza conexão Socket.IO global do partial de notificações -->
<script>
const socket = window.appSocket || notificationsSocket;
const chatName = "<%= chatName %>"; 
console.log("[Chat] Reutilizando conexão Socket.IO existente para:", chatName);
let allMessages = [];
let loadedStart = 0;
let loadedEnd = 0;
const batchSize = 50;
const bufferSize = 100;
let currentPage = 1;
let loading = false;

const chatContainer = document.getElementById("chat-container");
const loader = document.getElementById("loader");
let currentUser = null;
let chatId = null;

if (!socket) {
    console.error('[Chat] Socket.IO não disponível!');
}

// ==================== Renderização de mensagens ====================
function renderMessage(msgData, prepend = false) {
    ChatUtils.renderMessage(msgData, chatContainer, {
        isMine: msgData.tipo === 'usuario',
        showUsername: true,
        showTime: false,
        prepend
    });
}

function renderMessagesInitial(){
    chatContainer.innerHTML = "";
    if(loadedEnd === 0) return; // não há mensagens ainda

    for(let i = loadedStart; i < loadedEnd; i++){
        renderMessage(allMessages[i]);
    }
    chatContainer.scrollTop = chatContainer.scrollHeight;
}

// ==================== Busca de mensagens ====================
async function fetchMessages(page, isInitial = false){
    if(loading) return;
    loading = true;
    
    const loadingIndicator = ChatUtils.createLoadingIndicator();
    if (isInitial) {
        chatContainer.innerHTML = '';
        chatContainer.appendChild(loadingIndicator);
    } else {
        chatContainer.insertBefore(loadingIndicator, chatContainer.firstChild);
    }

    try {
        const res = await fetch(`/api/chats/${chatName}/messages?page=${page}`, {
            credentials: 'include' // importante para enviar cookies
        });
        if(!res.ok) throw new Error("Erro ao buscar mensagens");
        const data = await res.json();

        // Converte formato do backend para o frontend
        const formatted = data.messages.map(msg => ({
            id: msg.id,
            text: msg.mensagem,
            mensagem: msg.mensagem,
            username: msg.username,
            nome: msg.username,
            tipo: msg.isMine ? "usuario" : "outrousuario"
        }));

        if(isInitial) {
            // Carregamento inicial: exibe as mensagens mais recentes
            allMessages = formatted;
            loadedStart = 0;
            loadedEnd = allMessages.length;
            
            chatContainer.innerHTML = '';
            if (allMessages.length === 0) {
                chatContainer.appendChild(ChatUtils.createEmptyMessage('Nenhuma mensagem ainda'));
            } else {
                renderMessagesInitial();
            }
            
            // Busca chatId e entra na sala Socket.IO
            const chatRes = await fetch(`/api/chats`, { credentials: 'include' });
            const chats = await chatRes.json();
            const currentChat = chats.find(c => c.nome === chatName);
            if (currentChat) {
                chatId = currentChat.id;
                socket.emit('joinChat', chatId);
                console.log('[Socket] Entrando no chat:', chatId);
                
                // Marca mensagens como lidas após carregar
                socket.emit('markAsRead', { chatId });
            }
        } else {
            // Carregando mensagens antigas (scroll para cima)
            allMessages = [...formatted, ...allMessages];
            loadedStart = 0;
            loadedEnd = allMessages.length;
            
            // Guarda a posição de scroll atual
            const oldScrollHeight = chatContainer.scrollHeight;
            
            // Re-renderiza tudo
            chatContainer.innerHTML = "";
            for(let i = 0; i < allMessages.length; i++){
                renderMessage(allMessages[i]);
            }
            
            // Mantém a posição de scroll (adiciona a diferença de altura)
            chatContainer.scrollTop = chatContainer.scrollHeight - oldScrollHeight;
        }
    } catch(err){
        console.error(err);
        if(isInitial) {
            chatContainer.innerHTML = '';
            chatContainer.appendChild(ChatUtils.createErrorMessage());
        } else {
            const loadingIndicator = chatContainer.querySelector('.text-center.my-2');
            if (loadingIndicator) loadingIndicator.remove();
        }
    } finally {
        loading = false;
    }
}

// ==================== Scroll para carregar mensagens antigas ====================
let canLoadMore = true;

async function loadOlderMessages() {
    if(loading || !canLoadMore) return;
    if(chatContainer.scrollTop > 50) return; // Só carrega se estiver bem no topo
    
    console.log('Carregando mensagens antigas, página:', currentPage + 1);
    currentPage++;
    await fetchMessages(currentPage);
    
    // Se retornou menos mensagens que o limite, não há mais para carregar
    if(allMessages.length < currentPage * 50) {
        canLoadMore = false;
    }
}

chatContainer.addEventListener("scroll", () => {
    if(chatContainer.scrollTop === 0){
        loadOlderMessages();
    }
});

// ==================== Enviar nova mensagem ====================
const inputMsg = document.getElementById("input-msg");
const sendBtn = document.getElementById("send-btn");

ChatUtils.setupMessageInput(inputMsg, sendBtn, (text) => {
    if (!chatId) {
        console.error('[Chat] Chat ID não encontrado');
        return;
    }

    socket.emit('sendMessage', {
        chatId: chatId,
        mensagem: text
    });
});

// ==================== Socket.IO Events ====================
socket.on('joinedChat', ({ chatId, success }) => {
    if (success) {
        console.log('[Socket] Entrou no chat:', chatId);
    }
});

socket.on('newMessage', async (data) => {
    console.log('[Socket] Nova mensagem recebida:', data);
    
    const { chatId: msgChatId, message } = data;
    
    // Se é o chat atual, adiciona a mensagem
    if (msgChatId === chatId && message) {
        // Busca dados do usuário atual se ainda não tiver
        if (!currentUser) {
            const res = await fetch('/api/users/me', { credentials: 'include' });
            currentUser = await res.json();
        }

        const newMsg = {
            id: message.id,
            text: message.text,
            mensagem: message.text,
            username: message.username,
            nome: message.username,
            tipo: message.username === currentUser.username ? "usuario" : "outrousuario"
        };
        
        allMessages.push(newMsg);
        renderMessage(newMsg);
        loadedEnd++;
        
        // Remove mensagens antigas se ultrapassar o buffer
        if (chatContainer.children.length > bufferSize + 1) {
            chatContainer.removeChild(chatContainer.firstChild);
            loadedStart++;
        }
        
        chatContainer.scrollTop = chatContainer.scrollHeight;
        
        // Marca como lida automaticamente quando recebe mensagem de outro usuário
        // Isso garante que o contador seja zerado em tempo real
        if (message.username !== currentUser.username) {
            socket.emit('markAsRead', { chatId });
        }
    }
});

socket.on('messageRead', async (data) => {
    console.log('[Socket] Mensagens visualizadas:', data);
    
    const { chatId: readChatId, userId, lastReadMessageId } = data;
    
    // Atualiza checks de visualização apenas no chat atual
    if (readChatId === chatId) {
        // Busca dados do usuário atual se ainda não tiver
        if (!currentUser) {
            const res = await fetch('/api/users/me', { credentials: 'include' });
            currentUser = await res.json();
        }
        
        // Se outro usuário leu nossas mensagens, atualiza os checks
        if (userId !== currentUser.id) {
            // Atualiza visualmente: adiciona check duplo nas mensagens próprias que foram lidas
            const userMessages = chatContainer.querySelectorAll('.mensagem.usuario');
            userMessages.forEach(msgEl => {
                const msgId = parseInt(msgEl.dataset.msgId);
                if (msgId && msgId <= lastReadMessageId) {
                    // Remove check simples se existir e adiciona check duplo
                    const checkEl = msgEl.querySelector('.check-mark');
                    if (!checkEl) {
                        const metaEl = msgEl.querySelector('.msg-meta') || document.createElement('div');
                        if (!msgEl.querySelector('.msg-meta')) {
                            metaEl.className = 'msg-meta';
                            metaEl.style.fontSize = '0.65rem';
                            metaEl.style.color = 'gray';
                            metaEl.style.marginTop = '0.2rem';
                            metaEl.style.display = 'flex';
                            metaEl.style.alignItems = 'center';
                            metaEl.style.gap = '0.3rem';
                            msgEl.appendChild(metaEl);
                        }
                        const check = document.createElement('span');
                        check.className = 'check-mark';
                        check.innerHTML = '✔✔';
                        check.style.fontSize = '0.8rem';
                        check.style.color = '#4fc3f7';
                        metaEl.appendChild(check);
                    } else {
                        checkEl.innerHTML = '✔✔';
                        checkEl.style.color = '#4fc3f7';
                    }
                }
            });
        }
    }
});

socket.on('error', (error) => {
    console.error('[Socket] Erro:', error);
    alert('Erro: ' + error.message);
});

// ==================== Inicialização ====================
document.addEventListener("DOMContentLoaded", () => {
    fetchMessages(currentPage, true); // true = carregamento inicial
});
</script>
