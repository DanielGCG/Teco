<link rel="stylesheet" href="/styles/chat.css">
<link rel="stylesheet" href="/styles/global/chat-dm-common.css">

<div class="container-fluid h-100" style="padding: 0px;">
  <div class="card h-100 d-flex flex-column" style="background-color: var(--verde);">
    <div class="card-header text-center">
      <h5 class="mb-0"><%= locals.title %></h5>
    </div>

    <div id="chat-container" class="card-body position-relative" style="height:500px; overflow-y:auto; display:flex; flex-direction:column;">
      <div id="loader" class="text-center my-2" style="display:none;">
        <span class="spinner-border spinner-border-sm"></span> Carregando...
      </div>
    </div>

    <div class="card-footer">
      <div class="input-group">
        <textarea id="input-msg" class="form-control" placeholder="Digite sua mensagem..." rows="1" style="resize: none; overflow-y: auto; max-height: 120px;"></textarea>
        <button id="send-btn" class="btn btn-primary">Enviar</button>
      </div>
    </div>
  </div>
</div>

<!-- Módulos globais -->
<script src="/js/commons/ui-common.js"></script>
<script src="/js/commons/chat-dm-common.js"></script>

<!-- Reutiliza conexão Socket.IO global do partial de notificações -->
<script>
const socket = window.appSocket;
const chatName = "<%= chatName %>";
let allMessages = [];
let loadedStart = 0;
let loadedEnd = 0;
const bufferSize = 100;

const chatContainer = document.getElementById("chat-container");
const loader = document.getElementById("loader");
let currentUser = null;
let chatId = null;

if (!socket) {
    console.error('[Chat] Socket.IO não disponível!');
}

// Função de reconexão
function onSocketConnect() {
    if (chatId) {
        socket.emit('joinChat', chatId);
        socket.emit('getMessages', { chatId, page: 1 });
    }
}

// Registra handler de reconexão
if (window.SocketConnector) {
    SocketConnector.onReconnect(onSocketConnect);
}

// ==================== Renderização de mensagens ====================
function renderMessage(msgData, prepend = false) {
    ChatUtils.renderMessage(msgData, chatContainer, {
        isMine: msgData.tipo === 'usuario',
        showUsername: true,
        showTime: true,
        prepend
    });
}

function renderMessagesInitial(){
    chatContainer.innerHTML = "";
    if(loadedEnd === 0) return; // não há mensagens ainda

    for(let i = loadedStart; i < loadedEnd; i++){
        renderMessage(allMessages[i]);
    }
    chatContainer.scrollTop = chatContainer.scrollHeight;
}

// ==================== Enviar nova mensagem ====================
const inputMsg = document.getElementById("input-msg");
const sendBtn = document.getElementById("send-btn");

ChatUtils.setupMessageInput(inputMsg, sendBtn, (text) => {
    if (!chatId) {
        console.error('[Chat] Chat ID não encontrado');
        return;
    }

    socket.emit('sendMessage', {
        chatId: chatId,
        mensagem: text
    });
});

// ==================== Socket.IO Events ====================
socket.on('joinedChat', ({ chatId, success }) => {
    if (success) {
        console.log('[Socket] Entrou no chat:', chatId);
    }
});

socket.on('messagesLoaded', ({ chatId: loadedChatId, page, messages, hasMore }) => {
    // Armazena chatId na primeira vez
    if (!chatId) {
        chatId = loadedChatId;
        console.log('[Socket] Chat ID recebido:', chatId);
        socket.emit('joinChat', chatId);
    }
    
    // Ignora se não é o chat atual
    if (loadedChatId !== chatId) return;
    
    // Converte formato do backend para o frontend
    const formatted = messages.map(msg => ({
        id: msg.id,
        text: msg.mensagem,
        mensagem: msg.mensagem,
        username: msg.User?.username || msg.username,
        nome: msg.User?.username || msg.username,
        tipo: msg.isMine ? "usuario" : "outrousuario",
        createdAt: msg.created_at
    }));

    if (page === 1) {
        // Carregamento inicial
        allMessages = formatted;
        loadedStart = 0;
        loadedEnd = allMessages.length;
        renderMessagesInitial();
    }
});

socket.on('newMessage', async (data) => {
    console.log('[Socket] Nova mensagem recebida:', data);
    
    const { chatId: msgChatId, message } = data;
    
    // Se é o chat atual, adiciona a mensagem
    if (msgChatId === chatId && message) {

        const newMsg = {
            id: message.id,
            text: message.mensagem || message.text,
            mensagem: message.mensagem || message.text,
            username: message.username,
            nome: message.username,
            tipo: message.username === currentUser.username ? "usuario" : "outrousuario",
            createdAt: message.created_at || new Date().toISOString()
        };
        
        allMessages.push(newMsg);
        renderMessage(newMsg);
        loadedEnd++;
        
        // Remove mensagens antigas se ultrapassar o buffer
        if (chatContainer.children.length > bufferSize + 1) {
            chatContainer.removeChild(chatContainer.firstChild);
            loadedStart++;
        }
        
        chatContainer.scrollTop = chatContainer.scrollHeight;
        
        // Marca como lida automaticamente quando recebe mensagem de outro usuário
        if (message.username !== currentUser.username) {
            socket.emit('markAsRead', { chatId });
        }
    }
});

// Chat público não precisa de evento messageRead - apenas marca como lido no backend
socket.on('error', (error) => {
    console.error('[Socket] Erro:', error);
    alert('Erro: ' + error.message);
});

// ==================== Inicialização ====================
(async () => {
    const res = await fetch('/api/users/me', { credentials: 'include' });
    currentUser = await res.json();
    
    // Carrega mensagens iniciais via socket
    socket.emit('getMessages', { chatName, page: 1 });
})();
</script>
